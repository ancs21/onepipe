/**
 * Auth Builder
 *
 * Thin wrapper around better-auth for OnePipe integration
 *
 * @example
 * ```typescript
 * import { Auth } from '@onepipe/sdk'
 * import { betterAuth } from 'better-auth'
 *
 * // Create better-auth instance
 * const betterAuthInstance = betterAuth({
 *   database: {
 *     provider: 'sqlite',
 *     url: './auth.db',
 *   },
 *   emailAndPassword: {
 *     enabled: true,
 *   },
 *   socialProviders: {
 *     github: {
 *       clientId: process.env.GITHUB_CLIENT_ID!,
 *       clientSecret: process.env.GITHUB_CLIENT_SECRET!,
 *     },
 *   },
 * })
 *
 * // Wrap with OnePipe Auth
 * const auth = Auth
 *   .create('main')
 *   .provider(betterAuthInstance)
 *   .sessionCookie('onepipe_session')
 *   .build()
 *
 * // Use in REST API
 * const api = REST
 *   .create('protected')
 *   .basePath('/api/protected')
 *   .auth(auth)
 *   .get('/profile', async (ctx) => {
 *     // ctx.user is automatically populated
 *     return { user: ctx.user }
 *   })
 *   .build()
 *
 * // Role-based access
 * const adminApi = REST
 *   .create('admin')
 *   .basePath('/api/admin')
 *   .auth(auth, { roles: ['admin'] })
 *   .get('/users', async (ctx) => {
 *     return await ctx.db`SELECT * FROM users`
 *   })
 *   .build()
 * ```
 */

import { APIError, type AuthInstance, type AuthResult, type AuthUser, type AuthSession } from './types'

/**
 * Auth builder with fluent API
 *
 * Supports generic user types for type-safe user mapping:
 * @example
 * ```typescript
 * interface MyUser extends AuthUser {
 *   role: 'admin' | 'user'
 *   organizationId?: string
 * }
 *
 * const auth = Auth
 *   .create('auth')
 *   .provider(betterAuthInstance)
 *   .mapUser<MyUser>((session) => ({
 *     id: session.user.id,
 *     email: session.user.email,
 *     role: session.user.role as 'admin' | 'user',
 *     organizationId: session.user.organizationId,
 *   }))
 *   .build()
 * ```
 */

// Dev secret for dashboard JWT tokens (must match auth-store.ts)
const DEV_JWT_SECRET = 'onepipe-dev-secret'

/**
 * Verify and decode a dev JWT token from the dashboard
 * These tokens are generated by the dashboard for API testing
 */
function verifyDevToken(token: string): AuthUser | null {
  try {
    const parts = token.split('.')
    if (parts.length !== 3) return null

    const [headerB64, payloadB64, signatureB64] = parts

    // Verify signature using same method as auth-store.ts
    const signatureInput = `${headerB64}.${payloadB64}`
    const expectedSignature = new Bun.CryptoHasher('sha256')
      .update(signatureInput + DEV_JWT_SECRET)
      .digest()
    const expectedSignatureB64 = Buffer.from(expectedSignature).toString('base64url')

    if (signatureB64 !== expectedSignatureB64) {
      return null // Invalid signature
    }

    // Decode payload
    const payloadJson = Buffer.from(payloadB64, 'base64url').toString('utf-8')
    const payload = JSON.parse(payloadJson) as {
      sub: string
      email: string
      role: string
      iat: number
      exp: number
    }

    // Check expiration
    if (payload.exp < Math.floor(Date.now() / 1000)) {
      return null // Expired
    }

    // Return as AuthUser
    return {
      id: payload.sub,
      email: payload.email,
      role: payload.role,
      emailVerified: false,
    }
  } catch {
    return null
  }
}

export class AuthBuilder<TUser extends AuthUser = AuthUser> {
  private options: AuthBuilderOptions<TUser>

  constructor(name: string) {
    this.options = {
      name,
      basePath: '/api/auth',
      sessionCookie: 'session',
      headerName: 'Authorization',
      tokenPrefix: 'Bearer ',
    }
  }

  /**
   * Set the base path for auth routes (default: /api/auth)
   */
  basePath(path: string): this {
    this.options.basePath = path.replace(/\/$/, '')
    return this
  }

  /**
   * Set the better-auth provider instance
   */
  provider(betterAuth: BetterAuthInstance): this {
    this.options.provider = betterAuth
    return this
  }

  /**
   * Set session cookie name
   */
  sessionCookie(name: string): this {
    this.options.sessionCookie = name
    return this
  }

  /**
   * Set authorization header name
   */
  headerName(name: string): this {
    this.options.headerName = name
    return this
  }

  /**
   * Set token prefix (e.g., 'Bearer ')
   */
  tokenPrefix(prefix: string): this {
    this.options.tokenPrefix = prefix
    return this
  }

  /**
   * Set custom user mapper with type inference
   */
  mapUser<T extends AuthUser>(mapper: (session: BetterAuthSession) => T): AuthBuilder<T> {
    this.options.userMapper = mapper as unknown as (session: BetterAuthSession) => TUser
    return this as unknown as AuthBuilder<T>
  }

  /**
   * Build the auth instance
   */
  build(): AuthInstance<TUser> {
    if (!this.options.provider) {
      throw new Error('Auth requires a better-auth provider. Use .provider(betterAuth({...}))')
    }
    return new BetterAuthWrapper<TUser>(this.options)
  }
}

interface AuthBuilderOptions<TUser extends AuthUser = AuthUser> {
  name: string
  basePath: string
  provider?: BetterAuthInstance
  sessionCookie: string
  headerName: string
  tokenPrefix: string
  userMapper?: (session: BetterAuthSession) => TUser
}

/**
 * Better-auth instance interface
 * This matches the better-auth API
 */
interface BetterAuthInstance {
  api: {
    getSession: (options: { headers: Headers }) => Promise<BetterAuthSession | null>
  }
  handler: (request: Request) => Promise<Response>
}

interface BetterAuthSession {
  user: {
    id: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    role?: string | null
    [key: string]: unknown
  }
  session: {
    id: string
    userId: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress?: string | null
    userAgent?: string | null
    [key: string]: unknown
  }
}

/**
 * Better-auth wrapper implementation
 */
class BetterAuthWrapper<TUser extends AuthUser = AuthUser> implements AuthInstance<TUser> {
  readonly name: string
  readonly basePath: string
  private options: AuthBuilderOptions<TUser>
  private provider: BetterAuthInstance

  constructor(options: AuthBuilderOptions<TUser>) {
    this.name = options.name
    this.basePath = options.basePath
    this.options = options
    this.provider = options.provider!
  }

  /**
   * Get auth middleware for request validation
   * Supports both better-auth sessions and dev JWT tokens from dashboard
   */
  middleware(): (req: Request) => Promise<AuthResult<TUser>> {
    return async (req: Request): Promise<AuthResult<TUser>> => {
      try {
        // First, check for dev JWT token in Authorization header
        const authHeader = req.headers.get('authorization')
        if (authHeader?.startsWith('Bearer ')) {
          const token = authHeader.slice(7)
          const devUser = verifyDevToken(token)
          if (devUser) {
            return {
              authenticated: true,
              user: devUser as TUser,
            }
          }
        }

        // Fall back to better-auth session validation
        const session = await this.provider.api.getSession({
          headers: req.headers,
        })

        if (!session) {
          return {
            authenticated: false,
            error: APIError.unauthenticated('No valid session found'),
          }
        }

        const user = this.mapSessionToUser(session)

        return {
          authenticated: true,
          user,
        }
      } catch (error) {
        return {
          authenticated: false,
          error: APIError.unauthenticated(
            error instanceof Error ? error.message : 'Authentication failed'
          ),
        }
      }
    }
  }

  /**
   * Get middleware that requires specific role(s)
   */
  requireRole(role: string | string[]): (req: Request) => Promise<AuthResult<TUser>> {
    const roles = Array.isArray(role) ? role : [role]

    return async (req: Request): Promise<AuthResult<TUser>> => {
      const result = await this.middleware()(req)

      if (!result.authenticated) {
        return result
      }

      const userRole = result.user?.role
      if (!userRole || !roles.includes(userRole)) {
        return {
          authenticated: true,
          user: result.user,
          error: APIError.permissionDenied(`Required role: ${roles.join(' or ')}`),
        }
      }

      return result
    }
  }

  /**
   * Get middleware that requires specific permission(s)
   */
  requirePermission(permission: string | string[]): (req: Request) => Promise<AuthResult<TUser>> {
    const permissions = Array.isArray(permission) ? permission : [permission]

    return async (req: Request): Promise<AuthResult<TUser>> => {
      const result = await this.middleware()(req)

      if (!result.authenticated) {
        return result
      }

      const userPermissions = result.user?.permissions as string[] | undefined
      if (!userPermissions || !permissions.some((p) => userPermissions.includes(p))) {
        return {
          authenticated: true,
          user: result.user,
          error: APIError.permissionDenied(`Required permission: ${permissions.join(' or ')}`),
        }
      }

      return result
    }
  }

  /**
   * Get the better-auth handler for auth routes
   * Mount this at /api/auth/* for login, register, etc.
   */
  handler(): (req: Request) => Promise<Response> {
    return this.provider.handler
  }

  /**
   * Validate a token directly
   */
  async validateToken(token: string): Promise<AuthResult<TUser>> {
    const headers = new Headers()
    headers.set(this.options.headerName, `${this.options.tokenPrefix}${token}`)

    try {
      const session = await this.provider.api.getSession({ headers })

      if (!session) {
        return {
          authenticated: false,
          error: APIError.unauthenticated('Invalid token'),
        }
      }

      return {
        authenticated: true,
        user: this.mapSessionToUser(session),
      }
    } catch (error) {
      return {
        authenticated: false,
        error: APIError.unauthenticated(
          error instanceof Error ? error.message : 'Token validation failed'
        ),
      }
    }
  }

  /**
   * Map better-auth session to OnePipe AuthUser
   */
  private mapSessionToUser(session: BetterAuthSession): TUser {
    if (this.options.userMapper) {
      return this.options.userMapper(session)
    }

    return {
      id: session.user.id,
      email: session.user.email,
      name: session.user.name,
      role: session.user.role,
      emailVerified: session.user.emailVerified,
      image: session.user.image,
      sessionId: session.session.id,
      sessionExpiresAt: session.session.expiresAt,
    } as unknown as TUser
  }

  // =========================================================================
  // Session Management
  // =========================================================================

  /**
   * Get current session from request
   */
  async getSession(request: Request): Promise<AuthSession | null> {
    try {
      const session = await this.provider.api.getSession({
        headers: request.headers,
      })
      if (!session) return null

      return {
        id: session.session.id,
        userId: session.session.userId,
        token: session.session.token,
        expiresAt: session.session.expiresAt,
        createdAt: session.session.createdAt,
      }
    } catch {
      return null
    }
  }

  /**
   * List all active sessions for a user
   * Note: Requires better-auth to expose listSessions API
   */
  async listSessions(userId: string): Promise<AuthSession[]> {
    // better-auth may expose this via api.listSessions
    // For now, return empty array if not available
    const api = this.provider.api as { listSessions?: (opts: { userId: string }) => Promise<BetterAuthSession[]> }
    if (!api.listSessions) {
      console.warn('listSessions not available in better-auth provider')
      return []
    }

    try {
      const sessions = await api.listSessions({ userId })
      return sessions.map((s) => ({
        id: s.session.id,
        userId: s.session.userId,
        token: s.session.token,
        expiresAt: s.session.expiresAt,
        createdAt: s.session.createdAt,
      }))
    } catch {
      return []
    }
  }

  /**
   * Revoke a specific session
   * Note: Requires better-auth to expose revokeSession API
   */
  async revokeSession(sessionId: string): Promise<void> {
    const api = this.provider.api as { revokeSession?: (opts: { sessionId: string }) => Promise<void> }
    if (!api.revokeSession) {
      console.warn('revokeSession not available in better-auth provider')
      return
    }

    await api.revokeSession({ sessionId })
  }

  /**
   * Revoke all sessions for a user
   * Note: Requires better-auth to expose revokeSessions API
   */
  async revokeAllSessions(userId: string): Promise<void> {
    const api = this.provider.api as { revokeSessions?: (opts: { userId: string }) => Promise<void> }
    if (!api.revokeSessions) {
      console.warn('revokeAllSessions not available in better-auth provider')
      return
    }

    await api.revokeSessions({ userId })
  }
}

/**
 * Auth entry point
 */
export const Auth = {
  /**
   * Create a new auth builder
   */
  create(name: string): AuthBuilder {
    return new AuthBuilder(name)
  },
}

/**
 * Helper to create auth routes handler for use with REST
 *
 * @example
 * ```typescript
 * import { createAuthRoutes } from '@onepipe/sdk'
 *
 * // Mount auth routes at /api/auth/*
 * const authRoutes = createAuthRoutes(auth)
 * ```
 */
export function createAuthRoutes(auth: AuthInstance): {
  basePath: string
  handler: (req: Request) => Promise<Response>
} {
  const wrapper = auth as BetterAuthWrapper
  return {
    basePath: '/api/auth',
    handler: wrapper.handler(),
  }
}
